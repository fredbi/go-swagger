name: Test

permissions:
  contents: read
  pull-requests: read

# description: |
#   Test suite that runs on every commit (on pull requests, on merges to master).

on:
  pull_request:
  push:
    branches:
      - master

jobs:
  code-changed:
    # description: |
    #   Check for changes in source code.
    #
    #   We do not use "on.paths" because we want a PR workflow to run and be subject to
    #   status changes.
    #
    #   We also want to document on the github UI (as job summary) what the different
    #   stages of this workflow are doing.
    name: Check code changes
    runs-on: ubuntu-latest
    outputs:
      proceed_with_tests: >-
        ${{
           steps.changed-source-files.outputs.should_run_tests_any_changed == 'true' ||
           steps.changed-source-files.outputs.should_run_codegen_any_changed == 'true'
         }}
      proceed_with_codegen: ${{ steps.changed-source-files.outputs.should_run_codegen_any_changed }}
      proceed_with_docker: ${{ steps.changed-source-files.outputs.should_build_docker_any_changed }}
      proceed: >-
        ${{
          steps.changed-source-files.outputs.should_run_tests_any_changed == 'true' ||
          steps.changed-source-files.outputs.should_run_codegen_any_changed == 'true' ||
          steps.changed-source-files.outputs.should_build_docker_any_changed == 'true'
        }}
      other_changed_files: ${{ steps.changed-source-files.outputs.other_changed_files }}
    steps:
    - name: Originating repo checkout (e.g. public fork)
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      with:
        # will be empty on push to master and default to head from master
        ref: ${{ github.event.pull_request.head.ref }}
        repository: ${{ github.event.pull_request.head.repo.full_name }}

    - name: Get changed source files
      uses: tj-actions/changed-files@24d32ffd492484c1d75e0c0b894501ddb9d30d62 # v4.7.0
      id: changed-source-files
      with:
        files_yaml: |
          # Changes to anything in go source, templates or the way we test those.
          should_run_tests:
            - '**/go.{mod,sum}'
            - '**/*.{go,gotmpl}'
            - 'fixtures/**'
            - '!**/*.md'
            - '.github/workflows/test*.yaml'
            - '.golangci.yml'
            - '.codecov.yml'
          # Changes to anything that affects codegen.
          #
          # Approximation: some cmd/** commands do not affect codegen, but CLI
          # is affected and exercised by the codegen testing harness.
          should_run_codegen:
            - '**/go.(mod,sum)'
            - 'cmd/**/*.go'
            - '!cmd/swagger/commands/generate/spec*.go'
            - '!cmd/swagger/commands/diff/*.go'
            - 'generator/**'
            # codegen test program and configuration
            - 'hack/codegen*.go'
            - 'hack/*.yaml'
            # codegen test data
            - 'fixtures/**/*.(yaml,yml,json)'
            # codescan test data
            - '!fixtures/goparsing/**'
            - '!**/*.md'
          # Changes in the way we build and check docker images.
          # This assumes the repo builds normally and therefore only checks the dockerfile arrangements.
          should_build_docker:
            - '**/go.(mod,sum)'
            - 'Dockerfile'
            - '.hadolint.yml'
            - '.github/workflows/*docker*.yaml'

    - name: Notify
      run: |
        echo "::notice::Detection of changed source files"
        echo "should_run_tests_changed_files: ${{ steps.changed-source-files.outputs.should_run_tests_all_changed_files }}"
        echo "should_run_codegen_changed_files: ${{ steps.changed-source-files.outputs.should_run_codegen_all_changed_files }}"
        echo "should_build_docker_changed_files: ${{ steps.changed-source-files.outputs.should_build_docker_all_changed_files }}"
        echo "others: ${{ steps.changed-source-files.outputs.other_changed_files }}"

    - name: Workflow summary
      run: |
        function spew() {
         echo $1 >> "$GITHUB_STEP_SUMMARY"
        }

        spew "# Workflow summary"
        spew ""

        if [[ "${{ steps.changed-source-files.outputs.should_run_tests_any_changed }}" != "true" && \
              "${{ steps.changed-source-files.outputs.should_run_codegen_any_changed }}" != "true" && \
              "${{ steps.changed-source-files.outputs.should_build_docker_any_changed }}" != "true" \
           ]] ; then
          spew "1. [ ] Detect a change in source or the way we test it"
          spew "2. [x] All tests are skipped. Other workflows may kick in (e.g. doc update)"
          spew "3. [x] Tests completed: so PR may be approved"

          exit 0
        fi

        if [[ "${{ steps.changed-source-files.outputs.should_run_tests_any_changed }}" == "true" ]] ; then
          spew "1. [x] Detect a change in source or the way we test it"
          spew "2. [x] Lint go source code, including (generated examples)."
          spew "3. [x] Run a build (smoke) test (6x matrix)"
          spew "4. [x] Run unit tests (6x matrix)"
        else
          spew "1. [x] Did **not** detect a change in source or the way we test it"
          spew "2. [ ] Lint go source code, including (generated examples) (skipped)."
          spew "3. [ ] Run a build (smoke) test (6x matrix) (skipped)"
          spew "4. [ ] Run unit tests (6x matrix) (skipped)"
        fi

        if [[ "${{ steps.changed-source-files.outputs.should_run_codegen_any_changed }}" == "true" ]] ; then
          spew "5. [x] Run codegen integration tests (2x matrix)"
        else
          spew "5. [ ] Run codegen integration tests (2x matrix) (skipped)"
        fi

        if [[ "${{ steps.changed-source-files.outputs.should_build_docker_any_changed }}" == "true" ]] ; then
          spew "6. [x] Run build docker test"
        else
          spew "6. [ ] Run build docker test (skipped)"
        fi

        spew "7. [x] Tests completed: so PR may be approved"

        if [[ "${{ steps.changed-source-files.outputs.should_run_tests_any_changed }}" == "true" ]] ; then
          spew "8. [x] Merge test reports and publish (codecov, github)"
          spew "9. [x] Merge test coverage reports and publish (codecov)"
        else
          spew "8. [ ] Merge test reports and publish (codecov, github) (skipped)"
          spew "9. [ ] Merge test coverage reports and publish (codecov) (skipped)"
        fi

        spew ""
        spew "Steps (8) and (9) may sometimes fail and are not strictly required by PR check rules"

  lint:
    # description: |
    # Lint go source code.
    name: lint
    needs: [code-changed]
    if: ${{ needs.code-changed.outputs.proceed_with_tests == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
      - uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version: stable
          check-latest: true
          cache: true
      - name: golangci-lint
        uses: golangci/golangci-lint-action@4afd733a84b1f43292c63897423277bb7f4313a9 # v8.0.0
        with:
          args: --verbose
          only-new-issues: true
          skip-cache: true
          version: latest

  skip-test:
    # description: |
    #   Be explicit about tests being skipped, without blocking a PR.
    name: skipped tests
    needs: [code-changed]
    if: ${{ needs.code-changed.outputs.proceed != 'true' }}
    runs-on: ubuntu-latest
    steps:
    - name: Notify
      run: |
        echo "::notice::Linting and tests skipped: this PR doesn't change any code"
        echo "other_changed_files: ${{ needs.code-changed.outputs.other_changed_files }}"
        echo "procedd_with_tests: ${{ needs.code-changed.outputs.proceed_with_tests }}"
        echo "procedd_with_codegen: ${{ needs.code-changed.outputs.proceed_with_codegen }}"
        echo "procedd_with_docker: ${{ needs.code-changed.outputs.proceed_with_docker }}"
        echo "procedd: ${{ needs.code-changed.outputs.proceed }}"

  docker-test:
    name: test docker build
    needs: [code-changed]
    if: ${{ needs.code-changed.outputs.proceed_with_docker == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: ./.github/workflows/build-docker.yaml
        with:
          tag_sha: true
          pr: true

  build-test:
    # description: |
    #   Make sure we build and run elementary operations.
    #   The full test suite warrants support for the 2 latest go minor releases.
    name: build test
    needs: [code-changed, lint]
    if: ${{ needs.code-changed.outputs.proceed_with_tests == 'true' }}
    strategy:
      matrix:
        go: ["oldstable", "stable"]
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
      - uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version: ${{ matrix.go }}
          check-latest: true
          cache: true

      - name: Build binary
        run: |
          go install ./cmd/swagger

      - name: Verify that examples build
        run: |
          cd examples
          go build ./...
          go test ./...

      - name: Run validation tests
        run: |
          swagger validate fixtures/bugs/2493/fixture-2492.json
          swagger validate fixtures/bugs/2493/fixture-2493.json
          swagger validate fixtures/bugs/2493/fixture-2492.yaml
          swagger validate fixtures/bugs/2493/fixture-2493.yaml
          swagger validate fixtures/bugs/2866/2866.yaml

  unit-test:
    # description: |
    #   Run unit tests on the 2 most recent go releases and 3 popular platforms.
    name: unit test
    needs: [code-changed, lint]
    if: ${{ needs.code-changed.outputs.proceed_with_tests == 'true' }}
    strategy:
      matrix:
        go: ["oldstable", "stable"]
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}

      - uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version: ${{ matrix.go }}
          check-latest: true
          cache: true

      - name: Install Tools
        # TODO: pin version -> fork + update dedicated github action
        run: |
          go install gotest.tools/gotestsum@latest

      - name: Ensure TMP is created on windows runners
        # On windows, tests require testing.TempDir to reside on the same drive as the code.
        # TMP is used by os.TempDir() to determine the location of temporary files.
        if: ${{ runner.os  == 'Windows' }}
        shell: bash
        run: |
          TMP="${{ github.workspace }}\..\tmp"
          mkdir -p ${TMP}
          echo "TMP=${TMP}" >> "${GITHUB_ENV}"

      - name: Run unit tests with code coverage
        # * disabled test cache (windows): https://github.com/golang/go/issues/72992
        # * added json test report
        shell: bash
        run: >
          gotestsum
          --jsonfile 'unit.report.${{ matrix.os }}-${{ matrix.go }}.json'
          --
          -p 2
          -count 1
          -timeout=20m
          -coverprofile='unit.coverage.${{ matrix.os }}-${{ matrix.go }}.out'
          -covermode=atomic
          -coverpkg=$(go list)/...
          ./...

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          # *.coverage.* pattern is automatically detected by codecov
          path: '**/*.coverage.*.out'
          name: 'unit.coverage.${{ matrix.os }}-${{ matrix.go }}'
          retention-days: 1

      - name: Upload test report artifacts
        # upload report even if test fail. BTW, this is when they are valuable.
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          path: '**/unit.report.*.json'
          name: 'unit.report.${{ matrix.os }}-${{ matrix.go }}'
          retention-days: 1

  codegen-test:
    # description: |
    #   Exercise go-swagger from the command line, with a bunch of specs
    #   and several options (flatten/expand spec).
    #
    #   The test matrix applies to linux only. OS-specific quirks should
    #   be covered by unit tests.
    needs: [code-changed, lint]
    if: ${{ needs.code-changed.outputs.proceed_with_codegen == 'true' }}
    strategy:
      matrix:
        go: ["oldstable", "stable"]
        os: [ubuntu-latest]
        include:
          - fixture: codegen-fixtures # <- complex API specs to torture the code generator
            args: "-skip-models -skip-full-flatten -custom-formatter"
          - fixture: canary-fixtures # <- popular real-life API specs
            args: "-skip-models -skip-full-flatten -skip-expand -custom-formatter"
    runs-on: ${{ matrix.os }}
    env:
      GOCOVERDIR: /tmp/cov
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
      - uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version: ${{ matrix.go }}
          check-latest: true
          cache: true

      - name: Install Tools
        # TODO: pin this dependency
        run: |
          go mod download
          go get gotest.tools/icmd@latest
          mkdir /tmp/cov

      - name: Build binary with test coverage instrumentation
        run: |
          go install -a \
             --ldflags "-s -w" \
             -cover -covermode=atomic -coverpkg=$(go list)/... \
             ./cmd/swagger

      - name: Run codegen tests
        # TODO(fredbi): tests: nice to have - this test harness should output a json test report
        run: >
          /usr/bin/time
          go test -v -timeout 30m
          hack/codegen_nonreg_test.go
          -args -fixture-file "${{ matrix.fixture }}.yaml" ${{ matrix.args }}

      - name: Construct coverage reports from integration tests
        run: >
          go tool covdata textfmt
          -i "${GOCOVERDIR}"
          -o "codegen.coverage.${{ matrix.os }}-${{ matrix.go }}-${{ matrix.fixture }}.out"

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          path: '**/codegen.coverage.*.out'
          name: 'codegen.coverage.${{ matrix.os }}-${{ matrix.go }}'
          retention-days: 1

  test-complete:
    # description: |
    #   Be explicit about all tests being passed. This allows for setting up only a few status checks on PRs.
    name: tests completed
    needs: [code-changed, skip-test, build-test, codegen-test, unit-test, docker-test]
    if: ${{ !cancelled() }}
    runs-on: ubuntu-latest
    steps:
      - name: Tests completed
        if: ${{ needs.code-changed.outputs.proceed != 'true' }}
        run: |
          echo "::notice title=Success:All tests skipped (nothing to do)"

      - name: Tests completed
        if: >-
          ${{
              needs.code-changed.outputs.proceed_with_tests == 'true' &&
              needs.build-test.result == 'success' &&
              needs.unit-test.result == 'success'
           }}
        run: |
          echo "::notice title=Success:All unit tests completed"

      - name: Tests completed
        if: >-
          ${{
              needs.code-changed.outputs.proceed_with_codegen == 'true' &&
              needs.codegen-test.result == 'success'
           }}
        run: |
          echo "::notice title=Success:All codegen tests completed"

      - name: Tests completed
        if: >-
          ${{
              needs.code-changed.outputs.proceed_with_docker == 'true' &&
              needs.docker-test.result == 'success'
           }}
        run: |
          echo "::notice title=Success:All docker tests completed"

      - name: Tests failed
        if: >-
          ${{
              needs.code-changed.outputs.proceed == 'true' &&
              (
                (
                  needs.code-changed.outputs.proceed_with_tests == 'true' &&
                  (
                    needs.build-test.result != 'success' ||
                    needs.unit-test.result != 'success'
                  )
                ) ||
                (
                  needs.code-changed.outputs.proceed_with_codegen == 'true' &&
                  needs.codegen-test.result != 'success'
                ) ||
                (
                  needs.code-changed.outputs.proceed_with_docker == 'true' &&
                  needs.docker-test.result != 'success'
                )
              )
           }}
        run: |
          echo "::error title=Failure:Tests failed"

          exit 1

      - name: Ensure status
        run: |
          # This step is added to ensure that the next job in line will get a status
          exit 0

  collect-coverage:
    # description: |
    #   Gather, merge then uploads test coverage files from all test jobs (this includes integration tests,
    #   like codegen-test).
    name: collect test coverage
    needs: [test-complete, code-changed]
    if: ${{ !cancelled() && needs.test-complete.result == 'success' && needs.code-changed.outputs.proceed_with_tests == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}

      - name: Download coverage artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          run-id: "${{ github.run_id }}"
          pattern: "*.coverage.*"
          # artifacts resolve as folders
          path: coverage/

      - name: Upload coverage to codecov
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7 # v5.5.1
        with:
          name: Aggregated coverage
          # All *.coverage.*.out files uploaded should be detected by the codecov action.
          # NOTE: we lose the flags on individual test reports (e.g. by os, by go version, unit vs codegen)
          flags: '${{ matrix.go_version }}-${{ matrix.os }}'
          fail_ci_if_error: false
          verbose: false

  collect-reports:
    # description: |
    #   Gather, merge then uploads test report files from unit test jobs.
    #
    #   At this moment test reports are published on both codecov
    #   (see <https://app.codecov.io/gh/go-swagger/go-swagger/tests>) and the github actions UI
    #   (see <https://github.com/go-swagger/go-swagger/actions>).
    name: collect test reports
    needs: [code-changed, unit-test]
    if: ${{ needs.code-changed.outputs.proceed_with_tests == 'true' && !cancelled() }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version: stable
          check-latest: true
          cache: true

      - name: Download test report artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          run-id: "${{ github.run_id }}"
          pattern: "*.report.*"
          # artifacts resolve as folders
          path: reports/

      - name: Convert test reports to a merged JUnit XML
        # NOTE: codecov test reports only support JUnit format at this moment. See https://docs.codecov.com/docs/test-analytics.
        # Ideally, codecov improve a bit their platform, so we may only need a single pass to CTRF format.
        #
        # As a contemplated alternative, we could use gotestsum above to produce the JUnit XML directly.
        # At this moment, we keep a json format to dispatch test reports to codecov as well as to CTRF reports.
        #
        # TODO(fredbi): sec compliance - pin go-junit-report
        # TODO(fredbi): investigate - use mikepenz/action-junit-report@v5, that packages most of the following scripts
        # in a single action. Alternative: for that action.
        run: |
          go install github.com/jstemmer/go-junit-report/v2@latest
          go-junit-report -version

          find reports/ -name \*.json | xargs cat | go-junit-report -parser gojson -out=reports/junit_report.xml

      - name: Upload test results to Codecov
        # This allows for using the test results UI on codecov
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7 # v5.5.1
        with:
          files: '**/junit_report.xml'
          report_type: 'test_results'
          fail_ci_if_error: false
          handle_no_reports_found: true
          verbose: true

      - name: Convert test reports to CTRF JSON
        # description: |
        #   This step publishes CTRF test reports on github UI (actions)
        # TODO: pin this dependency
        run: |
          go install github.com/ctrf-io/go-ctrf-json-reporter/cmd/go-ctrf-json-reporter@v0.0.10

          appName="go-swagger"
          buildNumber="${{ github.run_id }}"
          appVersion="${{ github.event.pull_request.head.sha }}"

          # reconstruct platform information from the file name
          # set -x
          while read report ; do
            # echo "::notice::converting report: ${report}"
            # 'unit.report.${{ matrix.os }}-${{ matrix.go }}.json'
            reformated=$(echo "${report##*/}"|sed -E 's/(go)([[:digit:]]+)\.([[:digit:]]+)/\1\2\3/') # e.g. go1.24 becomes go124
            mapfile -d'.' -t -s 2 -n 2 split < <(echo $reformated) # skip the first 2 parts, stop on 2 more parts
            envstring="${split[0]}"
            osPlatform="${envstring%-*}"
            osRelease="${envstring##*-}"

            # this is a best effort only: tests may be cancelled upstream and produce incorrect reports
            go-ctrf-json-reporter \
              -quiet \
              -appName "${appName}" \
              -appVersion "${appVersion}" \
              -buildNumber "${buildNumber}" \
              -osPlatform "${osPlatform}" \
              -osRelease "${osRelease}" \
              -output "./reports/ctrf_report_${osPlatform}_${osRelease}.json" < "${report}" || true
          done < <(find reports -name \*.json)

      # NOTE: at this moment, we don't upload CTRF reports as artifacts.
      # Some of the CTRF reports are therefore not available (flaky tests, history, ...).
      #
      # See https://github.com/ctrf-io/github-test-reporter?tab=readme-ov-file#report-showcase
      # for more reporting possibilities. At the moment, we keep it simple, as most advanced features
      # require a github token (thus adding the complexity of a separate workflow starting on pull_request_target).
      #
      # For the moment, we are contented with these simple reports. This is an opportunity to compare the insight they
      # provide as compared to what is uploaded to codecov.
      #
      # Codecov analytics are pretty poor at this moment. On the other hand, they manage the bot that pushes back
      # PR comments.
      #
      # They also handle the storage of past test reports, so as to assess flaky tests.
      - name: Publish Test Summary Results
        uses: ctrf-io/github-test-reporter@646f98cfc16c6f7a0e1f6100cabe2deb95dd2eef # v1.0.22
        with:
          report-path: 'reports/ctrf_report_*.json'
          use-suite-name: true
          summary-report: true             # post a report to the github actions summary
          github-report: true
          failed-folded-report: true
